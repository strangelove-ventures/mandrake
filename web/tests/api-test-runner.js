#!/usr/bin/env bun

/**
 * This script starts the Mandrake API server in a test environment,
 * runs the API integration tests, and then cleans up.
 * 
 * Features:
 * - Uses a temporary directory for MANDRAKE_HOME
 * - Uses a random available port to avoid conflicts
 * - Cleans up resources after tests complete
 * - Handles graceful shutdown of API server
 */

import { spawn } from 'node:child_process';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import { mkdtempSync, rmSync, mkdirSync } from 'node:fs';
import { tmpdir } from 'node:os';
import net from 'node:net';

// Get the project root directory
const __dirname = fileURLToPath(new URL('.', import.meta.url));
const rootDir = join(__dirname, '..', '..');
const apiPath = join(rootDir, 'packages', 'api');
const webPath = join(rootDir, 'web');

// Create a unique temporary directory for this test run
const tmpDir = mkdtempSync(join(tmpdir(), 'mandrake-test-'));
console.log(`Created temporary directory: ${tmpDir}`);

// Make sure the .mandrake subdirectory exists in the temp dir
const mandrakeDataDir = join(tmpDir, '.mandrake');
try {
  mkdirSync(mandrakeDataDir, { recursive: true });
  console.log(`Created Mandrake data directory: ${mandrakeDataDir}`);
} catch (error) {
  console.error('Error creating Mandrake data directory:', error);
}

// Keep track of the API server process
let apiServer = null;
let serverReady = false;
let serverPort = null;
let serverWasShutDown = false;

/**
 * Find a free port to use for the API server
 */
async function findFreePort() {
  return new Promise((resolve, reject) => {
    const server = net.createServer();
    server.unref();
    server.on('error', reject);
    server.listen(0, () => {
      const port = server.address().port;
      server.close(() => {
        resolve(port);
      });
    });
  });
}

/**
 * Start the API server
 */
async function startApiServer() {
  try {
    serverPort = await findFreePort();
    console.log(`ðŸš€ Starting Mandrake API server on port ${serverPort}...`);
    
    // Use spawn to start the API server with the temp directory
    apiServer = spawn('bun', ['src/index.ts'], {
      cwd: apiPath,
      env: {
        ...process.env,
        PORT: serverPort.toString(),
        NODE_ENV: 'test',
        MANDRAKE_HOME: tmpDir,
      },
      stdio: ['ignore', 'pipe', 'pipe'],
    });
    
    // Create a promise that resolves when the server is ready
    const readyPromise = new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Timed out waiting for API server to start'));
      }, 30000);
      
      apiServer.stdout.on('data', (data) => {
        const output = data.toString();
        console.log(`[API] ${output.trim()}`);
        
        // Check if the server is ready
        if (output.includes('Mandrake API is running at')) {
          clearTimeout(timeout);
          serverReady = true;
          resolve();
        }
      });
      
      apiServer.stderr.on('data', (data) => {
        const output = data.toString();
        console.error(`[API ERROR] ${output.trim()}`);
        
        // Ignore warnings and non-fatal errors (like workspace not found)
        if (output.includes('Error:') || output.includes('error:')) {
          if (output.includes('not found') || output.includes('warning')) {
            console.log('[API] Ignoring non-fatal error');
          } else {
            clearTimeout(timeout);
            reject(new Error(`API server error: ${output}`));
          }
        }
      });
      
      apiServer.on('exit', (code) => {
        if (code !== 0 && !serverWasShutDown) {
          clearTimeout(timeout);
          reject(new Error(`API server process exited unexpectedly with code ${code}`));
        }
      });
    });
    
    return readyPromise;
  } catch (error) {
    console.error('Failed to start API server:', error);
    shutdownServer();
    process.exit(1);
  }
}

/**
 * Run the API tests
 */
async function runTests() {
  console.log('âœ… API server is ready');
  console.log(`ðŸ§ª Running API tests against server at http://localhost:${serverPort}...`);
  
  try {
    // Create or update a temporary file with the API URL
    const apiUrlPath = join(webPath, 'tests', 'api-url.js');
    const apiUrlContent = `// This file is auto-generated by the test runner
export const API_BASE_URL = 'http://localhost:${serverPort}';
`;
    
    try {
      Bun.write(apiUrlPath, apiUrlContent);
      console.log(`Created API URL config at ${apiUrlPath}`);
    } catch (error) {
      console.error('Failed to create API URL config:', error);
    }
    
    // Use spawn to run the tests
    const testProcess = spawn('bun', ['test', 'tests/lib/api/resources'], {
      cwd: webPath,
      env: {
        ...process.env,
        API_TEST_MODE: 'integration',
        API_BASE_URL: `http://localhost:${serverPort}`,
      },
      stdio: 'inherit',
    });
    
    // Wait for tests to complete
    const testCode = await new Promise((resolve) => {
      testProcess.on('exit', resolve);
    });
    
    return testCode;
  } catch (error) {
    console.error('Error running tests:', error);
    return 1;
  }
}

/**
 * Gracefully shut down the server and clean up resources
 */
function shutdownServer() {
  if (!serverWasShutDown && apiServer && apiServer.pid) {
    console.log('ðŸ›‘ Shutting down API server...');
    serverWasShutDown = true;
    
    // Send SIGTERM to allow for graceful shutdown
    apiServer.kill('SIGTERM');
    
    // Force kill after a timeout if it doesn't exit cleanly
    setTimeout(() => {
      if (!apiServer.killed) {
        console.log('Force killing API server...');
        apiServer.kill('SIGKILL');
      }
    }, 5000);
  }
}

/**
 * Clean up temporary files
 */
function cleanup() {
  try {
    console.log(`ðŸ§¹ Cleaning up temporary directory: ${tmpDir}`);
    rmSync(tmpDir, { recursive: true, force: true });
  } catch (error) {
    console.error('Error cleaning up temporary directory:', error);
  }
}

/**
 * Main function to run the tests
 */
async function main() {
  try {
    // Set up clean shutdown
    process.on('SIGINT', () => {
      console.log('Caught interrupt signal');
      shutdownServer();
      cleanup();
      process.exit(0);
    });
    
    process.on('SIGTERM', () => {
      console.log('Caught termination signal');
      shutdownServer();
      cleanup();
      process.exit(0);
    });
    
    // Start the API server
    await startApiServer();
    
    // Run the tests
    const testCode = await runTests();
    
    // Shutdown and cleanup
    shutdownServer();
    cleanup();
    
    // Exit with the test exit code
    process.exit(testCode);
  } catch (error) {
    console.error('Test runner error:', error);
    shutdownServer();
    cleanup();
    process.exit(1);
  }
}

// Run the main function
main().catch((error) => {
  console.error('Unhandled error in main:', error);
  shutdownServer();
  cleanup();
  process.exit(1);
});