# Session Package Implementation Plan

## Overview

The session package coordinates between workspace, MCP, and provider packages to enable complete conversations with tool usage. Key responsibilities:

- Building context by combining system prompt, files, and dynamic content
- Orchestrating message handling between components
- Managing streaming responses and tool calls
- Updating session storage with results

## Core Interfaces

### SessionCoordinator

```typescript
interface SessionCoordinator {
  constructor(opts: {
    promptManager: PromptManager;
    sessionManager: SessionManager;
    mcpManager: MCPManager;
    modelsManager: ModelsManager;
    filesManager?: FilesManager;
    dynamicContextManager?: DynamicContextManager;
  });

  handleMessage(opts: {
    sessionId: string;
    request: string;
  }): Promise<void>;
}

// Generated byt the SessionCoordinator during handleMessage
interface Context {
  systemPrompt: SystemPrompt;
  files: File[];                    // Workspace files
  dynamicContext: ToolResponse[];   // Dynamic tool results
  messages: Message[];              // Message history
}

// Stored by the PromptManager
interface SystemPrompt {
  instructions: string;              // User supplied instructions
  tools: Tool[];                     // Tool list from MCP
  includeWorkspaceMetadata: boolean; // Workspace directory, etc.
  includeSystemInfo: boolean;        // System details, etc.
  includeDateTime: boolean;          // Current date/time
}
```

## Implementation Details

### File Structure

```sh
session/
├── src/
│   ├── index.ts             - Package exports
│   ├── coordinator.ts       - Main SessionCoordinator implementation
│   ├── prompt/
│   │   ├── index.ts         - SystemPrompt exports
│   │   ├── instructions.ts  - Core instructions
│   │   ├── capabilities.ts  - Capability definitions
│   │   ├── rules.ts         - Usage rules
│   │   └── environment.ts   - Environment handling
│   ├── errors.ts            - Custom error types
│   └── types.ts             - Shared type definitions
├── tests/
│   ├── coordinator.test.ts  - Core coordinator tests
│   ├── prompt/              - Prompt section tests
│   └── integration/
│       └── session.test.ts  - Full integration tests
└── tsconfig.json
```

### Key Components

1. SessionCoordinator
   - Builds context from system prompt and session data
   - Coordinates message handling between components
   - Updates session storage with results
   - Manages tool call lifecycle

2. SystemPrompt Organization
   - Modular sections for instructions, capabilities, rules
   - Dynamic tool list from MCP servers
   - Configurable environment inclusion
   - Clean separation of concerns

3. Context Assembly
   - File content from workspace
   - Dynamic context resolution
   - Message history management

## Testing Plan

### Unit Tests

1. Context Building

```typescript
test('buildContext assembles complete context', async () => {
  const coordinator = new SessionCoordinator(workspace, mcp, provider);
  const context = await coordinator.buildContext('session-1');
  
  // Verify all context pieces
  expect(context.systemPrompt).toBeDefined();
  expect(context.files).toHaveLength(2); // Example
  expect(context.dynamicContext).toBeDefined();
  expect(context.messages).toHaveLength(1);
});

test('resolves dynamic context during build', async () => {
  const coordinator = new SessionCoordinator(workspace, mcp, provider);
  const context = await coordinator.buildContext('session-1');
  
  // Verify tool calls resolved
  const dynamicResults = context.dynamicContext;
  expect(dynamicResults[0].toolName).toBe('list_files');
  expect(dynamicResults[0].result).toBeDefined();
});
```

2. Message Handling

```typescript
test('processes message with tools', async () => {
  const coordinator = new SessionCoordinator(workspace, mcp, provider);
  const context = await coordinator.buildContext('session-1');
  
  await coordinator.handleMessage({
    sessionId: 'session-1',
    request: 'List files in /tmp',
    context
  });

  // Verify DB updated with new turns
  const session = await workspace.getSession('session-1');
  expect(session.turns).toHaveLength(1);
});

test('handles streaming updates', async () => {
  const coordinator = new SessionCoordinator(workspace, mcp, provider);
  const context = await coordinator.buildContext('session-1');

  await coordinator.handleMessage({
    sessionId: 'session-1',
    request: 'Complex task with tools',
    context
  });

  // Verify turn updates happened
  const session = await workspace.getSession('session-1');
  const turn = session.turns[0];
  expect(turn.content).toHaveLength(3); // Multiple content chunks
  expect(turn.toolCalls).toHaveLength(1);
});
```

### Integration Tests

1. Full Session Flow

```typescript
test('completes full session with tools', async () => {
  const coordinator = new SessionCoordinator(workspace, mcp, provider);
  
  // First message
  const context1 = await coordinator.buildContext('session-1');
  await coordinator.handleMessage({
    sessionId: 'session-1',
    request: 'First message',
    context: context1
  });

  // Second message building on first
  const context2 = await coordinator.buildContext('session-1');
  await coordinator.handleMessage({
    sessionId: 'session-1',
    request: 'Follow up task',
    context: context2
  });

  // Verify full conversation state
  const session = await workspace.getSession('session-1');
  expect(session.rounds).toHaveLength(2);
  expect(session.turns).toHaveLength(2);
});
```

## Implementation Steps

1. Core Framework
   - [ ] Setup package structure
   - [ ] Define core types
   - [ ] Basic coordinator shell

2. System Prompt
   - [ ] Implement prompt sections
   - [ ] Add tool integration
   - [ ] Environment handling

3. Context Building
   - [ ] File gathering
   - [ ] Dynamic context resolution
   - [ ] Message assembly

4. Message Handling
   - [ ] Provider integration
   - [ ] Tool coordination
   - [ ] DB updates

5. Testing
   - [ ] Unit test coverage
   - [ ] Integration testing
   - [ ] Performance testing

## Example Usage

```typescript
// Initialize the session coordinator
const coordinator = new SessionCoordinator({
  promptManager: new PromptManager(),
  sessionManager: new SessionManager(),
  mcpManager: getMCPManager(),                       // Background service
  modelsManager: new ModelsManager(),
  filesManager: new FilesManager(),                  // Optional
  dynamicContextManager: new DynamicContextManager() // Optional
});

// Handle message
await coordinator.handleMessage({
  sessionId: 'session-1',
  request: 'Hello, can you help me with...',
});

// Handle subsequent messages
await coordinator.handleMessage({
  sessionId: 'session-1',
  request: 'Follow up request...',
});
```

## Notes

- Context is built fresh for each message to capture latest state
- Tool calls automatically update session storage
- Provider streams update turn content in real-time
- Dynamic context is resolved during context building
- System prompt sections kept modular for maintainability
